;; Big example showing mbqi divergence on the quic3 push-query.
;; See mbqi_diverge_small for the minimized example
(declare-fun Inv_tr3 () Bool)
(declare-fun Inv_tr2 () Bool)
(declare-fun Inv_tr1 () Bool)
(declare-fun Inv_tr0 () Bool)
(declare-fun Inv_ext0_n () Bool)
(declare-fun |vsolver#0| () Bool)
(declare-fun Inv_0_n () (Array Int Int))
(declare-fun Inv_1_n () (Array Int Int))
(declare-fun Inv_3_n () Int)
(declare-fun Inv_2_n () Int)
(declare-fun Inv_3_0 () Int)
(declare-fun aux!1_n () Int)
(declare-fun Inv_0_0 () (Array Int Int))
(declare-fun Inv_1_0 () (Array Int Int))
(declare-fun Inv_2_0 () Int)
(declare-fun aux!2_n () Int)
(declare-fun aux!3_n () Int)
(declare-fun |Inv#level_0!4| () Bool)
(declare-fun |Inv#reach_case_0_0| () Bool)
(declare-fun zk!0 () Int)
(declare-fun zk!1 () Int)
(declare-fun spacer_proxy!0 () Bool)
(declare-fun spacer_proxy!1 () Bool)
(declare-fun spacer_proxy!2 () Bool)
(declare-fun spacer_proxy!3 () Bool)
(declare-fun spacer_proxy!4 () Bool)
(declare-fun spacer_proxy!5 () Bool)
(declare-fun spacer_proxy!6 () Bool)
(declare-fun spacer_proxy!7 () Bool)
(declare-fun spacer_proxy!8 () Bool)
(declare-fun |Inv#level_1!19| () Bool)
(declare-fun spacer_proxy!9 () Bool)
(declare-fun |Inv#level_2!20| () Bool)
(assert (or (not |vsolver#0|) Inv_ext0_n Inv_tr0 Inv_tr1 Inv_tr2 Inv_tr3))
(assert (let ((a!1 (forall ((z1 Int))
             (! (not (<= (select Inv_1_n z1) 0)) :pattern ((select Inv_1_n z1)))))
      (a!2 (not (forall ((z1 Int))
                  (! (= (select Inv_0_n z1) 0) :pattern ((select Inv_0_n z1)))))))
(let ((a!3 (not (or (not (= Inv_2_n 0)) (not (= Inv_3_n 0)) (not a!1) a!2))))
  (or (not |vsolver#0|) (not Inv_tr0) a!3))))
(assert (let ((a!1 (not (= (+ Inv_3_n (* (- 1) Inv_3_0)) 1))))
(let ((a!2 (or (not (= Inv_2_0 Inv_2_n))
               (not (= Inv_0_n (store Inv_0_0 aux!1_n 1)))
               (not (= Inv_1_n (store Inv_1_0 aux!1_n Inv_3_0)))
               (not (= (select Inv_0_0 aux!1_n) 0))
               a!1)))
  (or (not |vsolver#0|) (not Inv_tr1) (not a!2)))))
(assert (let ((a!1 (or (not (= Inv_1_0 Inv_1_n))
               (not (= Inv_2_0 Inv_2_n))
               (not (= Inv_3_0 Inv_3_n))
               (not (= Inv_0_n (store Inv_0_0 aux!2_n 2)))
               (not (= (select Inv_0_0 aux!2_n) 1))
               (not (= (select Inv_1_n aux!2_n) Inv_2_n)))))
  (or (not |vsolver#0|) (not Inv_tr2) (not a!1))))
(assert (let ((a!1 (= (+ Inv_2_n (* (- 1) (select Inv_1_n aux!3_n))) 1)))
(let ((a!2 (or (not (= Inv_1_0 Inv_1_n))
               (not (= Inv_3_0 Inv_3_n))
               (not (= Inv_0_n (store Inv_0_0 aux!3_n 0)))
               (not (= (select Inv_0_0 aux!3_n) 2))
               (not a!1))))
  (or (not |vsolver#0|) (not Inv_tr3) (not a!2)))))
(assert (or (not |vsolver#0|) (not (or Inv_tr1 Inv_tr2 Inv_tr3)) |Inv#level_0!4|))
(assert (let ((a!1 (forall ((z1 Int))
             (! (not (<= (select Inv_1_0 z1) 0)) :pattern ((select Inv_1_0 z1)))))
      (a!2 (not (forall ((z1 Int))
                  (! (= (select Inv_0_0 z1) 0) :pattern ((select Inv_0_0 z1)))))))
(let ((a!3 (not (or (not (= Inv_2_0 0)) (not (= Inv_3_0 0)) (not a!1) a!2))))
  (or (not |vsolver#0|) (not Inv_tr1) a!3 |Inv#reach_case_0_0|))))
(assert (let ((a!1 (forall ((z1 Int))
             (! (not (<= (select Inv_1_0 z1) 0)) :pattern ((select Inv_1_0 z1)))))
      (a!2 (not (forall ((z1 Int))
                  (! (= (select Inv_0_0 z1) 0) :pattern ((select Inv_0_0 z1)))))))
(let ((a!3 (not (or (not (= Inv_2_0 0)) (not (= Inv_3_0 0)) (not a!1) a!2))))
  (or (not |vsolver#0|) (not Inv_tr2) a!3 |Inv#reach_case_0_0|))))
(assert (let ((a!1 (forall ((z1 Int))
             (! (not (<= (select Inv_1_0 z1) 0)) :pattern ((select Inv_1_0 z1)))))
      (a!2 (not (forall ((z1 Int))
                  (! (= (select Inv_0_0 z1) 0) :pattern ((select Inv_0_0 z1)))))))
(let ((a!3 (not (or (not (= Inv_2_0 0)) (not (= Inv_3_0 0)) (not a!1) a!2))))
  (or (not |vsolver#0|) (not Inv_tr3) a!3 |Inv#reach_case_0_0|))))
(assert (let ((a!1 (not (<= (+ zk!1 (* (- 1) zk!0)) 0))))
  (or (not |vsolver#0|) (not spacer_proxy!0) a!1)))
(assert (or (not |vsolver#0|) (not spacer_proxy!1) (<= (select Inv_0_n zk!0) 2)))
(assert (or (not |vsolver#0|) (not spacer_proxy!2) (>= (select Inv_0_n zk!0) 2)))
(assert (or (not |vsolver#0|) (not spacer_proxy!3) (<= (select Inv_0_n zk!1) 2)))
(assert (or (not |vsolver#0|) (not spacer_proxy!4) (>= (select Inv_0_n zk!1) 2)))
(assert (or (not |vsolver#0|) (not spacer_proxy!5) (not (<= (select Inv_0_n zk!0) 0))))
(assert (or (not |vsolver#0|)
    (not spacer_proxy!6)
    (not Inv_tr1)
    (<= (select Inv_0_0 zk!0) 0)))
(assert (or (not |vsolver#0|)
    (not spacer_proxy!7)
    (not Inv_tr2)
    (<= (select Inv_0_0 zk!0) 0)))
(assert (or (not |vsolver#0|)
    (not spacer_proxy!8)
    (not Inv_tr3)
    (<= (select Inv_0_0 zk!0) 0)))
(assert (or (not |vsolver#0|)
    (not Inv_tr1)
    (forall ((zk!0 Int)) (<= (select Inv_0_0 zk!0) 0))
    |Inv#level_1!19|))
(assert (or (not |vsolver#0|)
    (not Inv_tr2)
    (forall ((zk!0 Int)) (<= (select Inv_0_0 zk!0) 0))
    |Inv#level_1!19|))
(assert (or (not |vsolver#0|)
    (not Inv_tr3)
    (forall ((zk!0 Int)) (<= (select Inv_0_0 zk!0) 0))
    |Inv#level_1!19|))
(assert (let ((a!1 (not (forall ((zk!0 Int)) (<= (select Inv_0_n zk!0) 0)))))
  (or (not |vsolver#0|) (not spacer_proxy!9) a!1)))
(check-sat |vsolver#0| (not Inv_ext0_n) |Inv#level_0!4| (not |Inv#level_1!19|) (not |Inv#level_2!20|) spacer_proxy!9 )
(exit)
